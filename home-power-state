#!/usr/bin/env ruby

require 'net/http'
require 'stackdriver_simple'
require 'json'
require 'clamp'
require 'time'

# TODO HARD
# * temperature of hot water tank
# * heating state of the hot water system?

def die(msg)
  $stderr.puts msg
  exit(1)
end

class SensiboPod

  def initialize(data)
    @data = data
  end

  def name
    @data.fetch("room", {}).fetch("name", "")
  end

  def temperature
    @data.fetch("measurements", {}).fetch("temperature", "")
  end

  def humidity
    @data.fetch("measurements", {}).fetch("humidity", "")
  end

  def measurement_time
    @data.fetch("measurements", {}).fetch("time", {}).fetch("time","")
  end

  def ac_on
    @data.fetch("acState", {}).fetch("on", false)
  end

  def ac_fan_level
    @data.fetch("acState", {}).fetch("fanLevel", "")
  end

  def ac_mode
    @data.fetch("acState", {}).fetch("mode", "")
  end

  def ac_swing
    @data.fetch("acState", {}).fetch("swing", "")
  end

  def namespaced_attributes
    {
      "#{name}.temperature" => temperature,
      "#{name}.humidity_percent" => humidity,
      "#{name}.ac_on" => ac_on ? 1 : 0,
    }
  end
end

class SensiboClient
  def initialize(api_key)
    @api_key = api_key
  end

  def pods
    uri = URI("https://home.sensibo.com/api/v2/users/me/pods?fields=*&apiKey=#{@api_key}")
    response = Net::HTTP.get_response(uri)

    if response.code.to_i != 200
      []
    else
      data = JSON.load(response.body)
      result = data.fetch("result", [])
      result.map { |item| SensiboPod.new(item) }
    end
  end
end

class CollectSensiboData

  def execute(google_cloud_project, sensibo_api_key)
    puts Time.now.iso8601
    sensibo_data(sensibo_api_key).each do |name, value|
      write_gauge(google_cloud_project, name, value) unless value.nil?
    end
  end

  private

  # This assumes the following two ENV vars are set:
  #
  # * GOOGLE_APPLICATION_CREDENTIALS=<path-to-credentials>
  def write_gauge(google_cloud_project, name, value)
    StackdriverSimple.new(
      google_cloud_project: google_cloud_project
    ).submit_gauge(name, value)
  end

  def sensibo_data(api_key)
    sensibo = SensiboClient.new(api_key)
    sensibo.pods.inject({}) { |accum, pod|
      accum.merge(pod.namespaced_attributes)
    }
  end
end

class CollectInverterData

  def execute(google_cloud_project, inverter_ip)
    puts Time.now.iso8601
    inverter_data(inverter_ip).each do |name, value|
      write_gauge(google_cloud_project, name, value)
    end
    meter_data(inverter_ip).each do |name, value|
      write_gauge(google_cloud_project, name, value)
    end
  end

  private

  # This assumes the following two ENV vars are set:
  #
  # * GOOGLE_APPLICATION_CREDENTIALS=<path-to-credentials>
  def write_gauge(google_cloud_project, name, value)
    StackdriverSimple.new(
      google_cloud_project: google_cloud_project
    ).submit_gauge(name, value)
  end

  def inverter_data(inverter_ip)
    response = Net::HTTP.get_response(URI("http://#{inverter_ip}/solar_api/v1/GetPowerFlowRealtimeData.fcgi"))

    if response.code.to_i != 200
      {}
    else
      data = JSON.load(response.body)
      grid_draw_watts = data.fetch("Body", {}).fetch("Data", {}).fetch("Site",{}).fetch("P_Grid", 0) || 0
      power_watts = data.fetch("Body", {}).fetch("Data", {}).fetch("Site",{}).fetch("P_Load", 0) || 0
      generation_watts = data.fetch("Body", {}).fetch("Data", {}).fetch("Site",{}).fetch("P_PV", 0) || 0
      energy_day_wh = data.fetch("Body", {}).fetch("Data", {}).fetch("Site",{}).fetch("E_Day", 0) || 0

      {
        grid_draw_watts: grid_draw_watts,
        power_watts: power_watts.abs,
        generation_watts: generation_watts,
        energy_day_watt_hours: energy_day_wh,
      }
    end
  end

  def meter_data(inverter_ip)
    response = Net::HTTP.get_response(URI("http://#{inverter_ip}/solar_api/v1/GetMeterRealtimeData.cgi?Scope=System"))

    if response.code.to_i != 200
      {}
    else
      data = JSON.load(response.body)
      grid_voltage = data.fetch("Body", {}).fetch("Data", {}).fetch("0",{}).fetch("Voltage_AC_Phase_1", 0) || 0

      {
        grid_voltage: grid_voltage,
      }
    end
  end

end

class DaikinClient

  def initialize(ip:, secure: false, token: nil)
    @ip, @secure, @token = ip, secure, token
    @scheme = @secure ? "https" : "http"
  end

  def sensor_info
    response = get_response("#{@scheme}://#{@ip}/aircon/get_sensor_info")

    if response.code.to_i != 200
      {}
    else
      daikin_decode(response.body)
    end
  end

  def control_info
    response = get_response("#{@scheme}://#{@ip}/aircon/get_control_info")

    if response.code.to_i != 200
      {}
    else
      daikin_decode(response.body)
    end
  end

  def power_data
    response = get_response("#{@scheme}://#{@ip}/aircon/get_week_power")

    if response.code.to_i != 200
      {}
    else
      daikin_decode(response.body)
    end
  end

  private

  def get_response(uri)
    uri = URI(uri)
    case uri.scheme
    when "http" then
      Net::HTTP.get_response(uri)
    when "https" then
			http = Net::HTTP.new(uri.host, 443)
      http.use_ssl = true
      # normally I'd never do this, but the daikin controllers use a self signed cert and the traffic is
      # only over my local LAN. The risk seems low.
      http.verify_mode = OpenSSL::SSL::VERIFY_NONE
      request = Net::HTTP::Get.new(uri, ImmutableHeaderKey.new("X-Daikin-uuid") => @token)
      http.request(request) # Net::HTTPResponse object
    else
      raise ArgumentError, "Unrecognised URL format"
    end
  end

  def daikin_decode(string)
    CGI::unescape(string).split(",").each_with_object({}) { |item, accum|
      key, value = *item.split("=")
      accum[key] = value
    }
  end
end

# This is completely gross. However the capitalisaton in our "X-Daikin-uuid" is important,
# and this hack stops net/http from changing it. Props to https://github.com/jnunemaker/httparty/issues/406
class ImmutableHeaderKey < String
  def to_s
    self
  end
  def capitalize
    self
  end
  def downcase
    self
  end
end

class CollectDaikinData

  def execute(google_cloud_project, daikin_client, unit_prefix)
    puts Time.now.iso8601
    sensor_info(daikin_client).each do |name, value|
      write_gauge(google_cloud_project, "daikin.#{unit_prefix}.#{name}", value)
    end
    control_info(daikin_client).each do |name, value|
      write_gauge(google_cloud_project, "daikin.#{unit_prefix}.#{name}", value)
    end
    power_data(daikin_client).each do |name, value|
      write_gauge(google_cloud_project, "daikin.#{unit_prefix}.#{name}", value)
    end
  end

  private

  # This assumes the following two ENV vars are set:
  #
  # * GOOGLE_APPLICATION_CREDENTIALS=<path-to-credentials>
  def write_gauge(google_cloud_project, name, value)
    StackdriverSimple.new(
      google_cloud_project: google_cloud_project
    ).submit_gauge(name, value)
  end

  def sensor_info(daikin_client)
    data = daikin_client.sensor_info

    {
      inside_temp: data.fetch("htemp", "0").to_f,
      outside_temp: data.fetch("otemp", "0").to_f,
    }
  end

  def control_info(daikin_client)
    data = daikin_client.control_info

    {
      power: data.fetch("pow", "0").to_i,
      mode: data.fetch("mode", "0").to_i,
      set_temp: data.fetch("stemp", "0").to_f,
      fan_rate: data.fetch("f_rate", "0").to_i,
      fan_dir: data.fetch("f_dir", "0").to_i,
    }
  end

  def power_data(daikin_client)
    data = daikin_client.power_data
    days = data.fetch("datas", "").split("/")
    today_watt_hours = days.last

    if today_watt_hours
      {
        power_watt_hours: today_watt_hours.to_i,
      }
    else
      {}
    end
  end

end

Clamp do
  option "--gcp-project", "<name>", "A GCP project slug", required: true, environment_variable: "GCP_PROJECT"
  option "--inverter-ip", "<ip>", "An IP Address", required: true, environment_variable: "INVERTER_IP"
  option "--sensibo-api-key", "<key>", "API key", required: true, environment_variable: "SENSIBO_API_KEY"
  option "--daikin-ip", "<ip>", "An IP Address", required: true, environment_variable: "DAIKIN_IP"
  option "--daikin-prefix", "<name>", "prefix daikin metrics with this string (eg kitchen, lounge)", required: true, environment_variable: "UNIT_PREFIX"
  option "--daikin-secure-ip", "<ip>", "An IP Address", required: true, environment_variable: "DAIKIN_SECURE_IP"
  option "--daikin-secure-prefix", "<name>", "prefix daikin metrics with this string (eg kitchen, lounge)", required: true, environment_variable: "DAIKIN_SECURE_PREFIX"
  option "--daikin-secure-token", "<name>", "token for accessing a daikin unit over https", required: true, environment_variable: "DAIKIN_SECURE_TOKEN"

  subcommand "collect", "send data to honeycomb" do

    def execute
      run_until = Time.now + 260 # nearly 5 mins
      while Time.now < run_until
        CollectInverterData.new.execute(
          gcp_project,
          inverter_ip,
        )
        CollectSensiboData.new.execute(
          gcp_project,
          sensibo_api_key,
        )
        CollectDaikinData.new.execute(
          gcp_project,
          DaikinClient.new(ip: daikin_ip),
          daikin_prefix,
        )
        CollectDaikinData.new.execute(
          gcp_project,
          DaikinClient.new(ip: daikin_secure_ip, secure: true, token: daikin_secure_token),
          daikin_secure_prefix,
        )
        sleep(15)
      end
    end
  end
end
